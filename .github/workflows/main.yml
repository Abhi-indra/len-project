name: CI/CD Deploy via Bastion (Raw SSH + Debug)

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    environment: lens

    steps:
    # â”€â”€ BUILD & PUSH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - uses: actions/checkout@v3

    - id: vars
      run: echo "TAG=${GITHUB_SHA::8}" >>"$GITHUB_OUTPUT"

    - uses: docker/setup-buildx-action@v3

    - uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id:      ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region:             ${{ secrets.AWS_REGION }}

    - uses: aws-actions/amazon-ecr-login@v1

    - name: Build & push image
      run: |
        REPO=${{ secrets.ECR_REPO }}
        TAG=${{ steps.vars.outputs.TAG }}
        docker build -t "$REPO:$TAG" -t "$REPO:latest" -f application/Dockerfile application
        docker push "$REPO:$TAG"
        docker push "$REPO:latest"

    # â”€â”€ DEPLOY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: Deploy via bastion
      uses: appleboy/ssh-action@v1.0.0
      env:       # export for the *first* (bastion) shell
        AWS_REGION: ${{ secrets.AWS_REGION }}
        ECR_REPO:   ${{ secrets.ECR_REPO }}
        BACKEND_IP: ${{ secrets.EC2_BACKEND }}
        TAG:        ${{ steps.vars.outputs.TAG }}
      with:
        host:     ${{ secrets.EC2_BASTION }}
        username: ${{ secrets.EC2_USER }}
        key:      ${{ secrets.EC2_SSH_KEY }}
        timeout:  "120s"
        script: |
          set -euo pipefail

          # â”€â”€ 0) Guard clauses â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          for v in AWS_REGION ECR_REPO BACKEND_IP TAG; do
            printf '%s=%s***\n' "$v" "${!v:0:4}"
            if [[ -z "${!v:-}" ]]; then
              echo "::error::$v is empty â€“ check your secrets."
              exit 1
            fi
          done

          KEY=~/.ssh/lens.pem
          [[ -s $KEY ]] || { printf '%s\n' "${{ secrets.EC2_SSH_KEY }}" >"$KEY" && chmod 400 "$KEY"; }

          # â”€â”€ 1) Network check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          ping -c3 "$BACKEND_IP" || { echo "::warning::ping failed, continuing"; }

          # â”€â”€ 2) Hop to backend host â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          ssh -o StrictHostKeyChecking=no -i "$KEY" ${{ secrets.EC2_USER }}@"$BACKEND_IP" bash -s -- \
            "$AWS_REGION" "$ECR_REPO" "$TAG" <<'INNER'
            set -euo pipefail
            AWS_REGION=$1
            ECR_REPO=$2
            TAG=$3

            echo "ðŸŸ¢ On $(hostname) â€“ deploying $ECR_REPO:$TAG"

            aws ecr get-login-password --region "$AWS_REGION" \
              | docker login --username AWS --password-stdin "$ECR_REPO"

            docker pull "$ECR_REPO:$TAG" || docker pull "$ECR_REPO:latest"

            docker stop app 2>/dev/null || true
            docker rm   app 2>/dev/null || true
            docker run -d --restart=always --name app -p 5000:5000 "$ECR_REPO:$TAG"
INNER
